{"schemaVersion":{"minor":3,"major":0,"patch":0},"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/Me\/documentation\/Me\/004_PencilKit-Intro","doc:\/\/Me\/documentation\/Me\/003_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-II","doc:\/\/Me\/documentation\/Me\/002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I"]}],"sections":[],"kind":"article","metadata":{"images":[{"type":"icon","identifier":"WWDC24-Icon.png"},{"type":"card","identifier":"WWDC24.jpeg"}],"role":"article","roleHeading":"Key Takeaways from WWDC24","title":"Deep Dive into SwiftUI Containers","modules":[{"name":"Me"}],"platforms":[{"introducedAt":"2024.8.12","name":"","beta":false}]},"topicSectionsStyle":"detailedGrid","abstract":[{"type":"text","text":"This article delves into the new SwiftUI container APIs from WWDC24, showcasing how to build custom, flexible, and performant Layouts using advanced "},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":"\/"},{"code":"Group","type":"codeVoice"},{"type":"text","text":" initializers and "},{"code":"ContainerValues","type":"codeVoice"},{"text":". It covers practical implementations for section support, item limits, and expandable sections in iOS 18+ applications.","type":"text"}],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"anchor":"Introduction","text":"Introduction"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftUI has always offered a comprehensive range of container views designed to structure content and apply common visual appearances and behaviors. From the familiar "},{"code":"HStack","type":"codeVoice"},{"text":", ","type":"text"},{"code":"VStack","type":"codeVoice"},{"type":"text","text":", and "},{"type":"codeVoice","code":"ZStack"},{"type":"text","text":" for arranging elements to the more specialized "},{"code":"List","type":"codeVoice"},{"text":" for displaying collections of data, these containers have been instrumental in making UI development efficient and intuitive.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"At WWDC24, Apple introduced exciting new features and capabilities for container views in SwiftUI, expanding the toolkit available to developers. These advancements promise to provide even greater flexibility and control in layout design."},{"text":" ","type":"text"},{"text":"In this post, we‚Äôll explore these new features, with a particular focus on how to write custom containers. We‚Äôll see how these additions can enhance your app‚Äôs user interface and allow for more sophisticated layout structures that were previously challenging to implement.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Whether you‚Äôre a seasoned SwiftUI developer or just starting out, understanding these new container view features will be crucial for creating modern and visually appealing iOS apps. Let‚Äôs dive in and discover how WWDC24 has expanded the possibilities of SwiftUI containers."}]},{"type":"heading","level":2,"text":"Background","anchor":"Background"},{"inlineContent":[{"text":"Before diving into the new features from WWDC24, let‚Äôs quickly review what container views are in SwiftUI and why they‚Äôre important.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Container views are specialized components that organize and manage other views, playing a key role in building complex layouts. They handle the positioning and sizing of child views, allowing developers to create responsive and structured interfaces. By combining simpler views, containers enable the composition of more complex UIs. Additionally, certain containers, like "},{"code":"List","type":"codeVoice"},{"type":"text","text":", provide shared behaviors such as scrolling and selection."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Common built-in containers include:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"HStack"},{"text":" and ","type":"text"},{"code":"VStack","type":"codeVoice"},{"type":"text","text":" for horizontal and vertical layouts"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ZStack"},{"type":"text","text":" for overlaying views"}]}]},{"content":[{"inlineContent":[{"code":"List","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ForEach"},{"text":" for data collections","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"ScrollView","type":"codeVoice"},{"text":" for scrollable content","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"While these containers cover many needs, custom containers offer more specialized layouts. The new features introduced at WWDC24 enhance these capabilities, giving developers even more tools to create and customize container views. In the following sections, we‚Äôll explore these advancements and their impact on SwiftUI development.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The new features introduced at WWDC24 build upon this foundation, providing more powerful tools for creating and customizing container views. In the following sections, we‚Äôll explore these new capabilities and how they can enhance your SwiftUI development.","type":"text"}],"type":"paragraph"},{"text":"New Features for Container Views","anchor":"New-Features-for-Container-Views","type":"heading","level":2},{"inlineContent":[{"text":"In iOS 18.0, Apple introduced several new features in SwiftUI that add more flexibility for writing container views. These enhancements allow developers to create more versatile and customizable layouts. Let‚Äôs explore these new features in detail.","type":"text"}],"type":"paragraph"},{"type":"heading","level":3,"anchor":"New-ForEach-and-Group-Initializers","text":"New ForEach and Group Initializers"},{"inlineContent":[{"text":"Previously, creating custom container views with dynamic content was limited to using collections of a specific data type and a ","type":"text"},{"type":"codeVoice","code":"@ViewBuilder"},{"type":"text","text":" closure. Now, SwiftUI offers new initializers for "},{"code":"ForEach","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Group","type":"codeVoice"},{"text":" that provide greater flexibility:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension ForEach {","    public init<V>(subviews view: V, @ViewBuilder content: @escaping (Subview) -> Content) where Data == ForEachSubviewCollection<Content>, ID == Subview.ID, Content : View, V : View","}","","extension Group {","    public init<V>(subviews view: V, @ViewBuilder transform: @escaping (SubviewsCollection) -> Result) where Content == GroupElementsOfContent<Base, Result>, Base : View, Result : View","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"These new initializers allow you to create container views that are more flexible and generic, without relying on data-driven properties."}]},{"type":"heading","level":3,"anchor":"Flexible-Custom-Containers","text":"Flexible Custom Containers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let‚Äôs compare the old approach with the new one:"}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Old Approach:"}]}]},{"type":"codeListing","syntax":"swift","code":["struct CustomList<Item: Identifiable, Content: View>: View {","    let data: [Item]","    @ViewBuilder var content: (Item) -> Content","    var body: some View {","        ScrollView {","            ForEach(data) { item in","                CustomView(content: content(item))","            }","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"New Approach:","type":"text"}]}]},{"type":"codeListing","syntax":"swift","code":["struct CustomList<Content: View>: View {","    @ViewBuilder var content: Content","    var body: some View {","        ScrollView {","            ForEach(subviews: content) { subview in","                CustomView(content: subview)","            }","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new approach allows for more flexibility, enabling you to combine static items, multiple "},{"type":"codeVoice","code":"ForEach"},{"text":" statements, and different view types within the same container, without the need to rely on a data type.","type":"text"}]},{"type":"heading","text":"Section Support in Custom Containers","level":3,"anchor":"Section-Support-in-Custom-Containers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftUI now provides support for sections in custom container views through new initializers for "},{"type":"codeVoice","code":"Group"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["extension Group {","    public init<Base, Result>(sections view: Base, @ViewBuilder transform: @escaping (SectionCollection) -> Result) where Content == GroupSectionsOfContent<Base, Result>, Base : View, Result : View","}","","extension ForEach {","    public init<V>(sections view: V, @ViewBuilder content: @escaping (SectionConfiguration) -> Content) where Data == ForEachSectionCollection<Content>, ID == SectionConfiguration.ID, Content : View, V : View","}"]},{"type":"paragraph","inlineContent":[{"text":"These initializers allow you to extract and manage subviews grouped by sections, including their headers and footers.","type":"text"}]},{"level":3,"type":"heading","text":"ContainerValues for Customization","anchor":"ContainerValues-for-Customization"},{"inlineContent":[{"type":"text","text":"SwiftUI introduces "},{"type":"codeVoice","code":"ContainerValues"},{"type":"text","text":", a powerful tool for creating container-specific modifiers. Unlike "},{"type":"codeVoice","code":"EnvironmentValues"},{"text":" or ","type":"text"},{"code":"Preferences","type":"codeVoice"},{"text":", ","type":"text"},{"code":"ContainerValues","type":"codeVoice"},{"text":" are accessible only by the direct container, making them ideal for container-specific customizations.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here‚Äôs how to define and use a container value:"}],"type":"paragraph"},{"type":"codeListing","code":["extension ContainerValues {","    var isItemHighlighted: Bool = false","}","","extension View {","    func itemHighlighted(_ isHighlighted: Bool) -> some View {","        containerValue(\\.isItemHighlighted, isHighlighted)","    }","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"You can then apply and access these values in your custom container:"}],"type":"paragraph"},{"syntax":"swift","code":["struct CustomList<Content: View>: View {","    @ViewBuilder var content: Content","    var body: some View {","        ScrollView {","            Group(sections: content) { sections in","                ForEach(sections) { section in","                    ForEach(subviews: section.content) { subview in","                        let contentValues = subview.containerValues","                        CustomView(content: subview)","                            .bold(contentValues.isItemHighlighted)","                    }","                }","            }","        }","    }","}"],"type":"codeListing"},{"level":3,"anchor":"Key-Takeaways","text":"Key Takeaways","type":"heading"},{"inlineContent":[{"text":"These new features in SwiftUI for iOS 18.0 significantly enhance the flexibility and power of custom container views:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"New initializers for ","type":"text"},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":" and "},{"code":"Group","type":"codeVoice"},{"type":"text","text":" allow for more versatile content composition."}]}]},{"content":[{"inlineContent":[{"text":"Improved support for sections in custom containers enables better content organization.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"ContainerValues"},{"text":" provide a targeted way to customize individual items within a container.","type":"text"},{"text":" ","type":"text"},{"text":"These additions open up new possibilities for creating sophisticated, customizable layouts in SwiftUI.","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","level":2,"text":"Writing a Custom Container","anchor":"Writing-a-Custom-Container"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let‚Äôs move from theory to practice by creating a custom container for an app‚Äôs home feed. In this section, we‚Äôll implement a flexible and feature-rich container view using the new SwiftUI APIs introduced in iOS 18.0."}]},{"inlineContent":[{"text":"Throughout this tutorial, we‚Äôll cover:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Setting up the basic structure of a custom container"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Implementing support for both static and dynamic content","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Adding section support with headers and footers","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Customizing section layouts with horizontal and vertical orientations"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Limiting the number of items displayed in a section"}]}]},{"content":[{"inlineContent":[{"text":"Creating an expandable\/collapsible mechanism for sections with hidden items","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"By the end of this section, you‚Äôll have a practical understanding of how to leverage the new container APIs to create a versatile and customizable layout for your app‚Äôs home screen. This example will demonstrate how to aggregate content from various app features, making it an ideal solution for complex, content-rich interfaces.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Let‚Äôs dive in and start building our custom ","type":"text"},{"type":"codeVoice","code":"FeedContainer"},{"type":"text","text":"!"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We will start by declaring a new view called "},{"type":"codeVoice","code":"FeedContainer"},{"type":"text","text":", which will accept content view builder to resolve its sections and items."}]},{"syntax":"swift","type":"codeListing","code":["struct FeedContainer<Content: View>: View {","    @ViewBuilder var content: Content","","    var body: some View {","        content","    }","}"]},{"inlineContent":[{"type":"text","text":"The next step will be to use new initializer for Group that resolves all the sections from the content view builder. So now it is possible to iterate over each section using "},{"code":"ForEach","type":"codeVoice"},{"type":"text","text":" and just draw the content of the section (its items, header and footer if present)."}],"type":"paragraph"},{"syntax":"swift","code":["struct FeedContainer<Content: View>: View {","    @ViewBuilder var content: Content","","    var body: some View {","        ScrollView {","            LazyVStack {","                Group(sections: content) { sections in","                    ForEach(sections) { section in","                        if !section.header.isEmpty {","                            section.header","                        }","                        section.content","                        if !section.footer.isEmpty {","                            section.footer","                        }","                    }","                }","            }","        }","    }","}","","#Preview {","    FeedContainer {","        Section {","            Text(\"Item 1\")","            Text(\"Item 2\")","            Text(\"Item 3\")","        } header: {","            Text(\"Header\").bold()","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"It will look like this:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"001_feedcontainer_basic_structure.jpg","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We added support for both static and dynamic items (resolved by the content-view builder), as well as support for sections, including headers and footers."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The next step will be to add some custom behavior to the home feed. We want to add support for section Axis customization. The main idea is to provide a way for the container to determine how to present items within a section. To achieve this, the new "},{"type":"codeVoice","code":"ContainerValues"},{"type":"text","text":" API comes into play."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Let‚Äôs define a property in "},{"type":"codeVoice","code":"ContainerValues"},{"type":"text","text":" that will store the section Axis, along with a corresponding view modifier."}],"type":"paragraph"},{"code":["extension ContainerValues {","    var sectionAxis: Axis = .vertical","}","","extension View {","    func sectionAxis(_ axis: Axis) -> some View {","        containerValue(\\.sectionAxis, axis)","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This allows us to specify which layout to choose for the section. Now we need to update our implementation to support two different options for displaying section content. We will add two separate functions for both axes.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For the vertical case, we will wrap the section‚Äôs subview in a "},{"code":"LazyVStack","type":"codeVoice"},{"type":"text","text":". For the horizontal case, we will use the horizontal alternative, "},{"type":"codeVoice","code":"LazyHStack"},{"type":"text","text":", but we will also wrap it in a "},{"code":"ScrollView","type":"codeVoice"},{"text":" to enable scrolling through the section items.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we need to modify the body to use the appropriate builder function based on the axis. To do this, we should resolve the section content values and check the "},{"type":"codeVoice","code":"sectionAxis"},{"type":"text","text":" property."}]},{"type":"codeListing","syntax":"swift","code":["struct FeedContainer<Content: View>: View {","    \/\/ ...","    var body: some View {","        ScrollView {","            LazyVStack {","                Group(sections: content) { sections in","                    ForEach(sections) { section in","                        \/\/ ...","                        switch section.containerValues.sectionAxis {","                        case .vertical:","                            buildVerticalSection(section.content)","                        case .horizontal:","                            buildHorizontalSection(section.content)","                        }","                        \/\/ ...","                    }","                }","            }","        }","    }","    ","    private func buildVerticalSection(_ subviews: SubviewsCollectionSlice) -> some View {","        LazyVStack(spacing: 10) {","            subviews","        }","        .padding(.horizontal)","    }","    ","    private func buildHorizontalSection(_ subviews: SubviewsCollectionSlice) -> some View {","        ScrollView(.horizontal) {","            LazyHStack(spacing: 10) {","                subviews","            }","            .padding(.horizontal)","        }","    }","}","","#Preview {","    FeedContainer {","        Section {","            Text(\"Item 1\")","            Text(\"Item 2\")","            Text(\"Item 3\")","        } header: {","            Text(\"Vertical\").bold()","        }","        ","        Section {","            Text(\"Item 1\")","            Text(\"Item 2\")","            Text(\"Item 3\")","        } header: {","            Text(\"Horizontal\").bold()","        }","        .sectionAxis(.horizontal)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we can specify the axis for each section and display its items differently."}]},{"type":"paragraph","inlineContent":[{"identifier":"001_feedcontainer_section_axis_customization.jpeg","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we need to add support for limiting the number of items displayed in each section. The implementation algorithm is similar: declare a container values property to store the section limit, then obtain this value and filter the section subviews before displaying them."}]},{"inlineContent":[{"type":"text","text":"Since we want to use the "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":" function, which returns a "},{"type":"codeVoice","code":"SubviewsCollectionSlice"},{"type":"text","text":" instead of a "},{"type":"codeVoice","code":"SubviewsCollection"},{"text":", we need to adjust our approach. Let‚Äôs make the necessary changes to support this limitation as well.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here, you can see the updated version of "},{"type":"codeVoice","code":"FeedContainer"},{"type":"text","text":" with the changes mentioned above."}],"type":"paragraph"},{"code":["extension ContainerValues {","    var sectionItemsLimit: Int = 0","}","","extension View {","    func sectionItemsLimit(_ limit: Int) -> some View {","        containerValue(\\.sectionItemsLimit, limit)","    }","}","","struct FeedContainerV4<Content: View>: View {","    \/\/ ...","    var body: some View {","        ScrollView {","            LazyVStack {","                Group(sections: content) { sections in","                    ForEach(sections) { section in","                        \/\/ ...","                        let itemsLimit = section.containerValues.sectionItemsLimit","                        let subviews = section.content.prefix(itemsLimit > 0 ? itemsLimit : section.content.count)","                        switch section.containerValues.sectionAxis {","                        case .vertical:","                            buildVerticalSection(subviews)","                        case .horizontal:","                            buildHorizontalSection(subviews)","                        }","                        \/\/ ...","                    }","                }","            }","        }","    }","\/\/...","}","","#Preview {","    FeedContainer {","        Section {","            Text(\"Item 1\")","            Text(\"Item 2\")","            Text(\"Item 3\")","        } header: {","            Text(\"Vertical\").bold()","        }","        .sectionItemsLimit(2)","        ","        Section {","            Text(\"Item 1\")","            Text(\"Item 2\")","            Text(\"Item 3\")","        } header: {","            Text(\"Horizontal\").bold()","        }","        .sectionAxis(.horizontal)","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let‚Äôs take a look at what is now displayed in the preview."}]},{"inlineContent":[{"identifier":"001_feedcontainer_section_item_limit.jpeg","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"The first vertical section no longer shows the third item. This is because we limited the section to two items using our new ","type":"text"},{"code":"sectionItemsLimit","type":"codeVoice"},{"text":" modifier. This feature can be quite useful for home pages, where you typically don‚Äôt want to display all content but rather limit it to recent or most popular items.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We are nearly finished with our feature list for this sample app. However, one thing is still missing: the ability to display hidden items when the section item count is limited. Therefore, we need to add functionality for expanding and collapsing the section."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"But before we dive into that, let‚Äôs enhance our list‚Äôs appearance, which is easy and quick to do in SwiftUI. We‚Äôll create two different views for displaying text and color items and add some styling for the headers."}],"type":"paragraph"},{"code":["struct TextItem: View {","    let title: String","","    var body: some View {","        Text(title)","            .font(.body)","            .padding(10)","            .frame(maxWidth: .infinity, alignment: .leading)","            .background(Color.black.opacity(0.1).clipShape(RoundedRectangle(cornerRadius: 5)))","    }","}","","struct ColorItem: View {","    let color: Color","","    var body: some View {","        color","            .frame(width: 50, height: 50)","            .clipShape(RoundedRectangle(cornerRadius: 5, style: .circular))","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Now we need to update our preview to showcase all the functionality we‚Äôve added so far. We‚Äôll create:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A section with dynamic text items (data-driven): We‚Äôll apply an item limit to this section, and it will be displayed as a vertical list by default because we won‚Äôt specify its axis."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"A section with static items and a horizontal axis: This will demonstrate how a horizontal list appears."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"A section with color items: This will make our sample app more realistic. We‚Äôll provide a number of items that won‚Äôt fit on the screen to test scrolling in sections with a horizontal axis."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"By setting up these sections, we‚Äôll be able to fully demonstrate the features and functionality of our custom container."}],"type":"paragraph"},{"code":["#Preview {","    FeedContainer {","        Section {","            ForEach(1 ... 10, id: \\.self) { index in","                TextItem(title: \"Item \\(index)\")","            }","        } header: {","            Text(\"Dynamic Vertical section\")","        }","        .sectionItemsLimit(3)","        .id(AnyHashable(\"123\"))","","        Section {","            TextItem(title: \"Item 1\")","            TextItem(title: \"Item 2\")","            Text(\"Item 3\")","            TextItem(title: \"Item 4\")","        } header: {","            Text(\"Static Horizontal section\")","        }.sectionAxis(.horizontal)","","        Section {","            ColorItem(color: .red)","            ColorItem(color: .green)","            ColorItem(color: .blue)","            ColorItem(color: .brown)","            ColorItem(color: .pink)","            ColorItem(color: .purple)","            ColorItem(color: .cyan)","        } header: {","            Text(\"Static Horizontal section\")","        }.sectionAxis(.horizontal)","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This is how our preview looks now."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"001_feedcontainer_updated_preview.jpeg"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We have a fairly good UI, but we‚Äôre still missing some functionality. Specifically, we need to add support for expanding sections that have item limits. To address this, we‚Äôll introduce an optional toggle button in the section header. This button will only appear if a limit is specified and if the number of items exceeds this limit. The following code snippet demonstrates how we can implement this feature."}],"type":"paragraph"},{"code":["struct FeedContainer<Content: View>: View {","    \/\/ ...","    @State private var expandedSections = Set<SectionConfiguration.ID>()","","    var body: some View {","        ScrollView(.vertical) {","            LazyVStack(spacing: 0) {","                Group(sections: content) { sections in","                    ForEach(sections) { section in","                        let itemsLimit = section.containerValues.sectionItemsLimit","                        let isExpanded = expandedSections.contains(section.id)","                        if !section.header.isEmpty {","                            HStack(alignment: .center) {","                                section.header","                                    .font(.title)","                                    .frame(maxWidth: .infinity, alignment: .leading)","                                if itemsLimit > 0, section.content.count > itemsLimit {","                                    Button(action: {","                                        withAnimation {","                                            if isExpanded {","                                                expandedSections.remove(section.id)","                                            } else {","                                                expandedSections.insert(section.id)","                                            }","                                        }","                                    }) {","                                        Image(systemName: isExpanded ? \"rectangle.compress.vertical\" : \"rectangle.expand.vertical\")","                                    }","                                }","                            }","                            .padding()","                        }","","                        ","                        let subviews = section.content.prefix(!isExpanded && itemsLimit > 0 ? itemsLimit : section.content.count)","                        \/\/ ...","                    }","                }","            }","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"We declared an ","type":"text"},{"code":"expandedSections","type":"codeVoice"},{"text":" state property to hold a set of IDs for expanded sections. Since ","type":"text"},{"code":"SectionConfiguration","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"Identifiable","type":"codeVoice"},{"text":", we can use the ","type":"text"},{"code":"id","type":"codeVoice"},{"type":"text","text":" to store it for sections that need to be expanded."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The next step is to get the item limit for the section. We do this with ","type":"text"},{"code":"let itemsLimit = section.containerValues.sectionItemsLimit","type":"codeVoice"},{"text":". Then, we check if the section is expanded or not with ","type":"text"},{"code":"let isExpanded = expandedSections.contains(section.id)","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, for sections that exceed the item limit, we will show a button to expand or collapse them. We will use two icons from SF Symbols to represent the current action of the button when the user taps it. If the collection is not expanded, we will insert the section ID into "},{"type":"codeVoice","code":"expandedSections"},{"type":"text","text":". Otherwise, we will remove it from the set. To enhance the visual experience, we will wrap this action in a "},{"type":"codeVoice","code":"withAnimation"},{"type":"text","text":" block, which will add standard animation to the collection changes."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We have accomplished everything we planned. Let‚Äôs look at what we have now and how it works!"}]},{"type":"paragraph","inlineContent":[{"identifier":"001_feedcontainer_expandable_sections.gif","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Looks great! Of course, this is not a production UI, but it demonstrates an example of how we can create custom containers to meet our needs using the new container APIs."}]},{"level":2,"type":"heading","anchor":"Challenges-and-Solutions","text":"Challenges and Solutions"},{"type":"paragraph","inlineContent":[{"text":"While implementing our custom ","type":"text"},{"type":"codeVoice","code":"FeedContainer"},{"type":"text","text":", we encountered several challenges. Here‚Äôs how we addressed them:"}]},{"level":3,"type":"heading","anchor":"Mixing-Static-and-Dynamic-Content","text":"Mixing Static and Dynamic Content"},{"inlineContent":[{"inlineContent":[{"text":"Challenge:","type":"text"}],"type":"strong"},{"type":"text","text":" SwiftUI‚Äôs previous container views often required choosing between static or data-driven content."}],"type":"paragraph"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Solution:"}]},{"type":"text","text":" The new "},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":" initializer allowed us to seamlessly combine both types of content within our custom container."}],"type":"paragraph"},{"type":"heading","text":"Section-Specific Layouts","level":3,"anchor":"Section-Specific-Layouts"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Challenge:","type":"text"}]},{"type":"text","text":" We needed different layouts (horizontal and vertical) for different sections."}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Solution:"}],"type":"strong"},{"text":" We used ","type":"text"},{"code":"ContainerValues","type":"codeVoice"},{"text":" to store section-specific layout information, allowing each section to define its own axis.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"Limited Item Display with Expansion Option","level":3,"anchor":"Limited-Item-Display-with-Expansion-Option"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Challenge:","type":"text"}],"type":"strong"},{"text":" Implementing a way to limit displayed items while providing an expansion mechanism was complex.","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Solution:","type":"text"}],"type":"strong"},{"type":"text","text":" We used a combination of "},{"type":"codeVoice","code":"ContainerValues"},{"type":"text","text":" for storing item limits and state management for tracking expanded sections. This approach enabled us to create a flexible system for showing and hiding content."}]},{"anchor":"Performance-Considerations","type":"heading","text":"Performance Considerations","level":3},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Challenge:"}]},{"type":"text","text":" With potentially large amounts of content, performance could become an issue."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Solution:","type":"text"}]},{"type":"text","text":" We utilized "},{"code":"LazyVStack","type":"codeVoice"},{"type":"text","text":" and "},{"code":"LazyHStack","type":"codeVoice"},{"type":"text","text":" to ensure that only visible content is rendered. For horizontal scrolling sections, we nested "},{"code":"ScrollView","type":"codeVoice"},{"type":"text","text":" inside "},{"code":"LazyVStack","type":"codeVoice"},{"text":" to maintain efficiency.","type":"text"}]},{"anchor":"Consistent-Styling-Across-Different-Content-Types","type":"heading","text":"Consistent Styling Across Different Content Types","level":3},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Challenge:"}],"type":"strong"},{"type":"text","text":" Maintaining a consistent look while accommodating various content types (text, colors, etc.) was difficult."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Solution:","type":"text"}]},{"text":" We created reusable view components (","type":"text"},{"code":"TextItem","type":"codeVoice"},{"text":", ","type":"text"},{"code":"ColorItem","type":"codeVoice"},{"text":") that encapsulate styling, ensuring consistency across different content types.","type":"text"}]},{"anchor":"Animation-Smoothness","type":"heading","text":"Animation Smoothness","level":3},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Challenge:"}],"type":"strong"},{"type":"text","text":" Expanding and collapsing sections could lead to jerky transitions."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Solution:"}],"type":"strong"},{"text":" We wrapped our expand\/collapse logic in ","type":"text"},{"code":"withAnimation","type":"codeVoice"},{"text":" blocks to ensure smooth, native-feeling animations when revealing or hiding content.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By addressing these challenges, we created a flexible, performant, and visually appealing custom container capable of handling a wide variety of content types and layouts. This approach highlights the power and flexibility of the new SwiftUI container APIs."}]},{"anchor":"Summary","type":"heading","text":"Summary","level":2},{"type":"paragraph","inlineContent":[{"text":"In this article, we explored a new API in SwiftUI for creating custom containers. We examined the added functionality and how it can be utilized. Additionally, we built a sample app using these new APIs, addressing the challenges we encountered and how we resolved them. This article serves as a starting point for those looking to create custom containers in SwiftUI with specific behavior.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"It‚Äôs important to note that these new APIs will only be available in iOS 18.0 and Xcode 16. As both iOS and Xcode are currently unreleased, the APIs are still in beta, and changes might occur (for example, the naming currently differs slightly from what was shown in the WWDC session). You‚Äôll need to wait for the next public release to use these APIs, and your app‚Äôs deployment target must be iOS 18.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"As SwiftUI continues to evolve, staying updated on these developments will be crucial for developers looking to leverage the full potential of custom containers in their apps. Keep experimenting, and don‚Äôt hesitate to share your experiences with the community!","type":"text"}]},{"inlineContent":[{"text":"For more detailed information about these changes, please refer to the Demystify SwiftUI containers WWDC24 session.","type":"text"}],"type":"paragraph"}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/me\/001_deep-dive-into-swiftui-containers-key-takeaways-from-wwdc24"]}],"identifier":{"url":"doc:\/\/Me\/documentation\/Me\/001_Deep-Dive-into-SwiftUI-Containers-Key-Takeaways-from-WWDC24","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/Me\/documentation\/Me","doc:\/\/Me\/documentation\/Me\/Blog"]]},"references":{"doc://Me/documentation/Me/002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I":{"kind":"article","images":[{"identifier":"kotlin_swift_bridge_logo.png","type":"icon"},{"type":"card","identifier":"kotlin_swift_bridge_logo.png"}],"abstract":[{"type":"text","text":"This article explores Kotlin Flow with Swift Combine in Kotlin Multiplatform projects. It details converting between "},{"type":"codeVoice","code":"Flow"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":", highlighting the challenges of type erasure and generics in Swift\/Objective-C interoperability, and demonstrates potential runtime issues."}],"role":"article","type":"topic","identifier":"doc:\/\/Me\/documentation\/Me\/002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I","title":"I. Kotlin Flow to Swift Combine: A KMP Bridge.","url":"\/documentation\/me\/002_kotlin-flow-to-swift-combine-a-kmp-bridge-part-i"},"blog-card.png":{"variants":[{"url":"\/images\/Me\/blog-card.png","traits":["1x","light"]},{"url":"\/images\/Me\/blog-card~dark.png","traits":["1x","dark"]}],"type":"image","alt":null,"identifier":"blog-card.png"},"001_feedcontainer_section_axis_customization.jpeg":{"identifier":"001_feedcontainer_section_axis_customization.jpeg","type":"image","alt":"FeedContainer with section axis customization","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/001_feedcontainer_section_axis_customization.jpeg"}]},"001_feedcontainer_basic_structure.jpg":{"alt":"FeedContainer basic structure","identifier":"001_feedcontainer_basic_structure.jpg","type":"image","variants":[{"url":"\/images\/Me\/001_feedcontainer_basic_structure.jpg","traits":["1x","light"]}]},"001_feedcontainer_expandable_sections.gif":{"variants":[{"traits":["1x","light"],"url":"\/images\/Me\/001_feedcontainer_expandable_sections.gif"}],"identifier":"001_feedcontainer_expandable_sections.gif","alt":"FeedContainer with expandable sections","type":"image"},"blog-icon.png":{"alt":null,"identifier":"blog-icon.png","variants":[{"url":"\/images\/Me\/blog-icon.png","traits":["1x","light"]},{"traits":["1x","dark"],"url":"\/images\/Me\/blog-icon~dark.png"}],"type":"image"},"doc://Me/documentation/Me/004_PencilKit-Intro":{"abstract":[{"type":"text","text":"This article is a step into the series of articles about building a drawing app with "},{"identifier":"https:\/\/developer.apple.com\/documentation\/pencilkit","type":"reference","isActive":true},{"type":"text","text":". In it, I will try to explain the basics and give some general understanding about the framework."}],"images":[{"type":"icon","identifier":"PencilKit-icon.png"},{"type":"card","identifier":"PencilKit-card.jpg"}],"type":"topic","title":"Introduction to the PencilKit","identifier":"doc:\/\/Me\/documentation\/Me\/004_PencilKit-Intro","kind":"article","url":"\/documentation\/me\/004_pencilkit-intro","role":"article"},"WWDC24.jpeg":{"variants":[{"url":"\/images\/Me\/WWDC24.jpeg","traits":["1x","light"]}],"type":"image","alt":null,"identifier":"WWDC24.jpeg"},"profile-icon.png":{"type":"image","variants":[{"url":"\/images\/Me\/profile-icon.png","traits":["1x","light"]}],"identifier":"profile-icon.png","alt":null},"doc://Me/documentation/Me/003_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-II":{"title":"II. Kotlin Flow to Swift Combine: A KMP Bridge.","identifier":"doc:\/\/Me\/documentation\/Me\/003_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-II","abstract":[{"text":"This article resolves KMP type-safety issues when bridging Kotlin Flows to Swift Combine. It uses ","type":"text"},{"type":"codeVoice","code":"MultiplatformFlow"},{"type":"text","text":", a generic wrapper, to ensure type safety in both directions, enabling consistent compile-time error detection across Android and iOS."}],"images":[{"type":"icon","identifier":"kotlin_swift_bridge_logo.png"},{"type":"card","identifier":"kotlin_swift_bridge_logo.png"}],"kind":"article","url":"\/documentation\/me\/003_kotlin-flow-to-swift-combine-a-kmp-bridge-part-ii","type":"topic","role":"article"},"001_feedcontainer_updated_preview.jpeg":{"variants":[{"traits":["1x","light"],"url":"\/images\/Me\/001_feedcontainer_updated_preview.jpeg"}],"alt":"FeedContainer updated preview with TextItem and ColorItem","type":"image","identifier":"001_feedcontainer_updated_preview.jpeg"},"WWDC24-Icon.png":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/WWDC24-Icon.png"}],"identifier":"WWDC24-Icon.png","alt":null},"doc://Me/documentation/Me":{"title":"Me","abstract":[{"text":"Software Engineer, primarily Mobile üì± (iOS üçé, Ex-Android ü§ñ)","type":"text"}],"identifier":"doc:\/\/Me\/documentation\/Me","images":[{"type":"icon","identifier":"profile-icon.png"}],"type":"topic","url":"\/documentation\/me","kind":"symbol","role":"collection"},"doc://Me/documentation/Me/Blog":{"abstract":[],"images":[{"identifier":"blog-icon.png","type":"icon"},{"type":"card","identifier":"blog-card.png"}],"type":"topic","title":"Blog","identifier":"doc:\/\/Me\/documentation\/Me\/Blog","kind":"article","url":"\/documentation\/me\/blog","role":"collectionGroup"},"001_feedcontainer_section_item_limit.jpeg":{"variants":[{"url":"\/images\/Me\/001_feedcontainer_section_item_limit.jpeg","traits":["1x","light"]}],"alt":"FeedContainer with section item limit","type":"image","identifier":"001_feedcontainer_section_item_limit.jpeg"},"PencilKit-icon.png":{"identifier":"PencilKit-icon.png","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/PencilKit-icon.png"}],"alt":null,"type":"image"},"kotlin_swift_bridge_logo.png":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/kotlin_swift_bridge_logo.png"}],"identifier":"kotlin_swift_bridge_logo.png","alt":null},"PencilKit-card.jpg":{"variants":[{"url":"\/images\/Me\/PencilKit-card.jpg","traits":["1x","light"]}],"alt":null,"type":"image","identifier":"PencilKit-card.jpg"},"https://developer.apple.com/documentation/pencilkit":{"title":"PencilKit","url":"https:\/\/developer.apple.com\/documentation\/pencilkit","titleInlineContent":[{"text":"PencilKit","type":"text"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/pencilkit"}}}