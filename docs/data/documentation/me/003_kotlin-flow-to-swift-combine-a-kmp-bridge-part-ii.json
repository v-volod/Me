{"hierarchy":{"paths":[["doc:\/\/Me\/documentation\/Me","doc:\/\/Me\/documentation\/Me\/Blog"]]},"seeAlsoSections":[{"identifiers":["doc:\/\/Me\/documentation\/Me\/002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I","doc:\/\/Me\/documentation\/Me\/001_Deep-Dive-into-SwiftUI-Containers-Key-Takeaways-from-WWDC24"],"generated":true}],"schemaVersion":{"minor":3,"major":0,"patch":0},"sections":[],"topicSectionsStyle":"detailedGrid","identifier":{"url":"doc:\/\/Me\/documentation\/Me\/003_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-II","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"This article resolves KMP type-safety issues when bridging Kotlin Flows to Swift Combine. It uses "},{"code":"MultiplatformFlow","type":"codeVoice"},{"type":"text","text":", a generic wrapper, to ensure type safety in both directions, enabling consistent compile-time error detection across Android and iOS."}],"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/me\/003_kotlin-flow-to-swift-combine-a-kmp-bridge-part-ii"]}],"metadata":{"title":"II. Kotlin Flow to Swift Combine: A KMP Bridge.","images":[{"identifier":"kotlin_swift_bridge_logo.png","type":"icon"},{"identifier":"kotlin_swift_bridge_logo.png","type":"card"}],"modules":[{"name":"Me"}],"role":"article","platforms":[{"introducedAt":"2024.8.28","name":"","beta":false}],"roleHeading":"Part II"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"Introduction","type":"heading","level":2,"text":"Introduction"},{"type":"paragraph","inlineContent":[{"text":"In the ","type":"text"},{"identifier":"002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I","type":"reference","isActive":true},{"type":"text","text":" of this article, we explored how to connect Kotlin‚Äôs Flows with Swift‚Äôs Combine Publishers. We also examined the limitations of Kotlin‚Äôs interoperability with Swift\/Objective-C and the pitfalls these limitations can create. In this part, we will explore a potential solution to this problem."}]},{"type":"heading","anchor":"Bringing-Type-Safety-for-KMP-APIs-in-iOS","text":"Bringing Type Safety for KMP APIs in iOS","level":2},{"type":"paragraph","inlineContent":[{"text":"As you may remember, Kotlin‚Äôs generic interfaces lose type information during translation to Swift\/Objective-C. As a result, the API becomes type-unsafe and complex to integrate. Therefore, we need to find a way to preserve the type information.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The Kotlin documentation on generics interoperability states that generics are only supported when defined on classes. It seems like this is the only viable approach.","type":"text"}]},{"type":"heading","level":3,"anchor":"Building-a-Generic-Preserving-Flow","text":"Building a Generic-Preserving Flow"},{"inlineContent":[{"type":"text","text":"Let‚Äôs create a wrapper class that has a generic parameter and implements the Flow interface. Since we are working on a multiplatform project, we‚Äôll name it "},{"type":"codeVoice","code":"MultiplatformFlow"},{"text":". As a wrapper, we‚Äôll add a constructor parameter to accept the wrapped Flow and use it as a delegate for the Flow interface implementation. For convenience, we‚Äôll also add an extension function on the Flow interface to facilitate wrapping.","type":"text"}],"type":"paragraph"},{"syntax":"java","type":"codeListing","code":["open class MultiplatformFlow<T : Any>(delegate: Flow<T>) : Flow<T> by delegate","","fun <T : Any> Flow<T>.multiplatform(): MultiplatformFlow<T> = MultiplatformFlow(this)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, let‚Äôs try to apply it to the input of our "},{"type":"codeVoice","code":"TextEncoder"},{"type":"text","text":":"}]},{"type":"codeListing","code":["class TextEncoder(rawText: MultiplatformFlow<TextString>) {","    @OptIn(ExperimentalEncodingApi::class)","    val encodedText: Flow<TextString> \/\/ ...","}"],"syntax":"java"},{"text":"Providing Type-Safe Flow from Swift","type":"heading","level":3,"anchor":"Providing-Type-Safe-Flow-from-Swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When we try to build our project, it fails. For Android, all we need to do is call the "},{"type":"codeVoice","code":"multiplatform()"},{"type":"text","text":" function on the text input flow, which will wrap it and fix the type mismatch:"}]},{"type":"codeListing","code":["class ContentViewModel : ViewModel() {","    private val _rawText = MutableStateFlow(\"\")","    \/\/ ...","    private val textEncoder = TextEncoder(","        rawText = _rawText.map { TextString(it) }.multiplatform()","    )","    \/\/ ...","}"],"syntax":"java"},{"type":"paragraph","inlineContent":[{"text":"However, on iOS, we now need to wrap the ","type":"text"},{"type":"codeVoice","code":"Publisher"},{"text":" into ","type":"text"},{"code":"MultiplatformFlow","type":"codeVoice"},{"text":" to prevent us from using a type-unsafe implementation. Let me remind you how the basic implementation looks:","type":"text"}]},{"syntax":"swift","code":["extension Publishers {","    final class FlowCollector<Output, Failure>: Publisher where Failure: Error {","        private let flow: Kotlinx_coroutines_coreFlow","        init(flow: Kotlinx_coroutines_coreFlow) {","            self.flow = flow","        }","        func receive<S>(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {","            let subscription = FlowCollectorSubscription(subscriber: subscriber, flow: flow)","            subscriber.receive(subscription: subscription)","            subscription.collect()","        }","    }","}","","fileprivate final class FlowCollectorSubscription<S>: Subscription, Kotlinx_coroutines_coreFlowCollector where S: Subscriber {","    struct TypeCastError: LocalizedError {","        let receivedType: Any.Type","        let expectedType: Any.Type","        var errorDescription: String? {","            \"Failed to cast value of type \\(receivedType) to expected type \\(expectedType).\"","        }","    }","    var subscriber: S?","    let flow: Kotlinx_coroutines_coreFlow","    var collectionTask: Task<Void, Never>?","","    init(subscriber: S?, flow: Kotlinx_coroutines_coreFlow) {","        self.subscriber = subscriber","        self.flow = flow","    }","","    func request(_ demand: Subscribers.Demand) { }","","    func collect() {","        collectionTask = .detached { @MainActor [weak self] in","            guard let self else { return }","            do {","                try await flow.collect(collector: self)","            } catch {","                if let error = error as? S.Failure {","                    subscriber?.receive(completion: .failure(error))","                } else {","                    subscriber?.receive(completion: .finished)","                }","            }","        }","    }","","    func cancel() {","        collectionTask?.cancel()","        collectionTask = nil","        subscriber = nil","    }","","    func emit(value: Any?) async throws {","        guard let expectedValue = value as? S.Input else {","            throw TypeCastError(receivedType: type(of: value), expectedType: S.Input.self)","        }","        _ = subscriber?.receive(expectedValue)","    }","}","","extension Kotlinx_coroutines_coreFlow {","    func publisher<Output, Failure>(","        outputType: Output.Type = Output.self,","        failureType: Failure.Type = Failure.self) -> Publishers.FlowCollector<Output, Failure> where Failure: Error {","        Publishers.FlowCollector(flow: self)","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since we won‚Äôt implement the "},{"type":"codeVoice","code":"Kotlinx_coroutines_coreFlowCollector"},{"type":"text","text":" protocol anymore, it makes sense to remove the "},{"code":"FlowCollector","type":"codeVoice"},{"text":" publisher altogether. While this means we can‚Äôt reuse our collector publisher in Combine chains, we don‚Äôt really need that functionality. All we need is to provide a ","type":"text"},{"type":"codeVoice","code":"MultiplatformFlow"},{"type":"text","text":" instance to the "},{"type":"codeVoice","code":"TextEncoder"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"codeVoice","code":"MultiplatformFlow"},{"text":" is a class, so we can‚Äôt implement it as a protocol. This means we need a way to construct it from Swift. If we refer to the Kotlin documentation for flows, we can find several helper functions that create ","type":"text"},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" instances based on different needs. One of them is called "},{"type":"codeVoice","code":"callbackFlow"},{"type":"text","text":"."}],"type":"paragraph"},{"style":"note","type":"aside","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Creates an instance of a cold Flow with elements that are sent to a SendChannel provided to the builder‚Äôs block of code via ProducerScope. It allows elements to be produced by code that is running in a different context or concurrently."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It seems that this one best fits our needs. Here is an example of its usage from the documentation:"}]},{"type":"codeListing","syntax":"java","code":["fun <T> flowFrom(api: CallbackBasedApi<T>): Flow<T> = callbackFlow {","    val callback = object : Callback<T> { \/\/ Implementation of some callback interface","        override fun onNextValue(value: T) {","            \/\/ To avoid blocking you can configure channel capacity using","            \/\/ either buffer(Channel. CONFLATED) or buffer(Channel. UNLIMITED) to avoid overfill","            trySendBlocking(value).onFailure { throwable ->","                \/\/ Downstream has been cancelled or failed, can log here","            }","        }","        override fun onApiError(cause: Throwable) {","            cancel(\"API Error\", cause)","        }","        override fun onCompleted() = channel.close()","    }","    api.register(callback)","    \/*","    * Suspends until either 'onCompleted'\/'onApiError' from the callback is invoked","    * or flow collector is cancelled (e. g. by 'take(1)' or because a collector's coroutine was cancelled).","    * In both cases, callback will be properly unregistered.","    *\/","    awaitClose { api.unregister(callback) }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, we can see that "},{"type":"codeVoice","code":"callbackFlow"},{"type":"text","text":" allows us to register, receive elements, and complete either with an error or successfully. This is exactly what Swift‚Äôs Combine "},{"type":"codeVoice","code":"Publisher"},{"text":" provides as well‚Äîyou can subscribe, receive value updates, and complete with or without failure.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately, global functions, in addition to interfaces, lose type information during translation to Objective-C\/Swift. This means we can‚Äôt use the "},{"type":"codeVoice","code":"callbackFlow"},{"type":"text","text":" builder function. Therefore, we need to create another class that extends "},{"code":"MultiplatformFlow","type":"codeVoice"},{"text":" and provides a type-safe way to subscribe to the publisher.","type":"text"}]},{"inlineContent":[{"type":"text","text":"What are our requirements? We need to be able to subscribe, unsubscribe, send elements, and\/or complete after a subscription is established. Sending elements and completing are tasks that we will handle within the context of "},{"code":"ProducerScope","type":"codeVoice"},{"text":". However, similar to the Flow interface, we don‚Äôt want to expose a typed protocol to iOS because we lose information about the type. Let‚Äôs start by implementing a wrapper for these operations.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["class MultiplatformProducerScope<T>(private val scope: ProducerScope<T>) {","    fun trySend(value: T) {","        scope.trySend(value)","    }","","    fun cancel(exception: CancellationException? = null) {","        scope.cancel(exception)","    }","","    fun close() {","        scope.channel.close()","    }","}"],"syntax":"java"},{"inlineContent":[{"type":"codeVoice","code":"MultiplatformProducerScope"},{"type":"text","text":" allows us to send elements and complete successfully by canceling the scope without an error, or complete with failure by canceling the scope with a provided "},{"type":"codeVoice","code":"CancellationException"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Now, let‚Äôs use this wrapper to expose the "},{"code":"callbackFlow","type":"codeVoice"},{"text":" function for constructing ","type":"text"},{"type":"codeVoice","code":"MultiplatformFlow"},{"text":" from iOS with type safety.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"java","code":["class MultiplatformCallbackFlow<T : Any>(","    subscribe: (MultiplatformProducerScope<T>) -> Unit,","    unsubscribe: () -> Unit",") : MultiplatformFlow<T>(","    callbackFlow {","        subscribe(MultiplatformProducerScope(this))","        awaitClose { unsubscribe() }","    }",")"]},{"inlineContent":[{"type":"text","text":"With its help, it is now possible to create a "},{"type":"codeVoice","code":"MultiplatformFlow"},{"type":"text","text":" instance, which we can then pass to the "},{"type":"codeVoice","code":"TextEncoder"},{"type":"text","text":". This will allow "},{"type":"codeVoice","code":"TextEncoder"},{"type":"text","text":" to subscribe to the "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" and send updates to it."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here‚Äôs how we can now convert a Swift Combine "},{"code":"Publisher","type":"codeVoice"},{"type":"text","text":" into a Kotlin "},{"code":"Flow","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["extension Publisher where Output: AnyObject {","    var flow: MultiplatformFlow<Output> {","        var cancellable: AnyCancellable?","        return MultiplatformCallbackFlow<Output> { scope in","            cancellable = sink { completion in","                switch completion {","                case let .failure(error):","                    scope.cancel(exception: KotlinCancellationException(message: error.localizedDescription))","                case .finished:","                    scope.close()","                }","            } receiveValue: { value in","                scope.trySend(value: value)","            }","        } unsubscribe: {","            cancellable?.cancel()","            cancellable = nil","        }","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We subscribe to the "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" via "},{"type":"codeVoice","code":"sink"},{"type":"text","text":", sending value updates in "},{"type":"codeVoice","code":"receiveValue"},{"type":"text","text":" through "},{"type":"codeVoice","code":"trySend"},{"type":"text","text":", and closing the scope if the "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" finishes, or canceling it with a provided description of the issue if it fails. If the flow collector stops collecting elements, unsubscribe will be called, and we can cancel the subscription using the cancellable instance of "},{"type":"codeVoice","code":"AnyCancellable"},{"type":"text","text":" returned by "},{"type":"codeVoice","code":"sink"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"That‚Äôs it! Now the iOS project will compile without any other changes.","type":"text"}]},{"level":3,"anchor":"Adding-Type-Safe-Flow-Support-in-Swift","text":"Adding Type-Safe Flow Support in Swift","type":"heading"},{"inlineContent":[{"text":"What about the ","type":"text"},{"code":"TextEncoder","type":"codeVoice"},{"text":" output? Now it‚Äôs time to make it type-safe as well. First, we need to specify the ","type":"text"},{"type":"codeVoice","code":"MultiplatformFlow"},{"type":"text","text":" class instead of the regular "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" interface."}],"type":"paragraph"},{"type":"codeListing","syntax":"java","code":["class TextEncoder(rawText: MultiplatformFlow<RawText>) {","    @OptIn(ExperimentalEncodingApi::class)","    val encodedText: MultiplatformFlow<EncodedText> = rawText.map { text ->","        EncodedText(Base64.encode(text.body.encodeToByteArray()))","    }.multiplatform()","}"]},{"inlineContent":[{"text":"For Android, we don‚Äôt need to change anything. The project will compile and work similarly to how it did before this change. iOS will compile as well since we‚Äôre still using the base ","type":"text"},{"code":"Kotlinx_coroutines_coreFlow","type":"codeVoice"},{"text":". Nevertheless, if we want to have a type-safe implementation on iOS as well, we need to make some changes. First, let‚Äôs expose a callback-style API in KMP to allow iOS to treat Kotlin‚Äôs ","type":"text"},{"code":"Flow","type":"codeVoice"},{"text":" as a callback and create a Combine ","type":"text"},{"code":"Publisher","type":"codeVoice"},{"type":"text","text":" from it. Unfortunately, we can‚Äôt expose "},{"code":"suspend","type":"codeVoice"},{"text":" functions with generics without losing type information. Because of that, we‚Äôll handle concurrency in Kotlin and expose the callback to Swift. Here‚Äôs how this utility function looks:","type":"text"}],"type":"paragraph"},{"syntax":"java","type":"codeListing","code":["open class MultiplatformFlow<T : Any> internal constructor(","    delegate: Flow<T>",") : Flow<T> by delegate {","    fun launchCollect(","        onEmit: (T) -> Unit,","        onCompletion: (Throwable?) -> Unit","    ): Job = MainScope().launch {","        try {","            collect(onEmit)","            onCompletion(null)","        } catch (e: Throwable) {","            onCompletion(e)","        }","    }","}"]},{"inlineContent":[{"text":"We launch a new coroutine in the ","type":"text"},{"code":"MainScope","type":"codeVoice"},{"text":" and return a reference to the ","type":"text"},{"code":"Job","type":"codeVoice"},{"type":"text","text":" instance, so we can cancel it if needed. We provide a closure for new elements with "},{"code":"onEmit","type":"codeVoice"},{"type":"text","text":" and for completion with "},{"type":"codeVoice","code":"onCompletion"},{"type":"text","text":". Using this, we can now rewrite our "},{"code":"FlowCollector","type":"codeVoice"},{"type":"text","text":" publisher and accept a type-safe "},{"code":"MultiplatformFlow","type":"codeVoice"},{"type":"text","text":" as input."}],"type":"paragraph"},{"code":["struct FlowError: LocalizedError {","    let throwable: KotlinThrowable","    var errorDescription: String? { throwable.message }","}","","extension Publishers {","    final class FlowCollector<Output: AnyObject>: Publisher {","        typealias Failure = FlowError","        private let flow: MultiplatformFlow<Output>","        init(flow: MultiplatformFlow<Output>) {","            self.flow = flow","        }","        func receive<S>(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {","            let subscription = FlowCollectorSubscription(subscriber: subscriber, flow: flow)","            subscriber.receive(subscription: subscription)","            subscription.collect()","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"First, we declared a specific ","type":"text"},{"code":"FlowError","type":"codeVoice"},{"text":" type that will wrap Kotlin‚Äôs ","type":"text"},{"code":"Throwable","type":"codeVoice"},{"text":". Then, we removed the ","type":"text"},{"code":"Failure","type":"codeVoice"},{"type":"text","text":" type parameter and specified "},{"code":"FlowError","type":"codeVoice"},{"type":"text","text":". We also replaced "},{"code":"Kotlinx_coroutines_coreFlow","type":"codeVoice"},{"type":"text","text":" with "},{"code":"MultiplatformFlow","type":"codeVoice"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"Now, let‚Äôs update ","type":"text"},{"code":"FlowCollectorSubscription","type":"codeVoice"},{"type":"text","text":" as well. We need to use the type-safe "},{"type":"codeVoice","code":"MultiplatformFlow"},{"type":"text","text":". Specify the "},{"code":"Failure","type":"codeVoice"},{"text":" type parameter as ","type":"text"},{"code":"FlowError","type":"codeVoice"},{"text":", and we should remove the ","type":"text"},{"code":"Kotlinx_coroutines_coreFlow","type":"codeVoice"},{"text":" conformance.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["fileprivate final class FlowCollectorSubscription<S>: Subscription where S: Subscriber, S.Input: AnyObject, S.Failure == FlowError {","    \/\/ ...","    let flow: MultiplatformFlow<S.Input>","    \/\/ ...","    init(subscriber: S?, flow: MultiplatformFlow<S.Input>) {","        self.subscriber = subscriber","        self.flow = flow","    }","    \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The final step will be to update the "},{"code":"collect","type":"codeVoice"},{"type":"text","text":" function to use "},{"code":"MultiplatformFlow","type":"codeVoice"},{"type":"text","text":"."}]},{"syntax":"swift","code":["fileprivate final class FlowCollectorSubscription<S>: Subscription where S: Subscriber, S.Input: AnyObject, S.Failure == FlowError {","    \/\/ ...","    var job: Kotlinx_coroutines_coreJob?","    \/\/ ...","    func collect() {","        job = flow.launchCollect { [weak self] value in","            _ = self?.subscriber?.receive(value)","        } onCompletion: { [weak self] error in","            if let error = error {","                self?.subscriber?.receive(completion: .failure(FlowError(throwable: error)))","            } else {","                self?.subscriber?.receive(completion: .finished)","            }","        }","    }","","    func cancel() {","        job?.cancel(cause: nil)","        job = nil","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the "},{"type":"codeVoice","code":"FlowCollector"},{"type":"text","text":" publisher is type-safe as well! To make the project compile again, all we need to do is remove the unnecessary "},{"type":"codeVoice","code":"Failure"},{"type":"text","text":" type parameter when instantiating the publisher from "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":". We could even remove the "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" type parameter as well, since the KMP shared library now provides a type-safe "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" that includes type information."}]},{"syntax":"swift","type":"codeListing","code":["final class ContentViewModel: ObservableObject {","    \/\/ ...","    private var encodedTextSubscription: AnyCancellable?","    init() {","        let textEncoder = TextEncoder(rawText: $rawText.map(TextString.init(body:)).flow)","        encodedTextSubscription = Publishers.FlowCollector(flow: textEncoder.encodedText)","        \/\/ ...","    }","}"]},{"inlineContent":[{"text":"We‚Äôre all done! Now it‚Äôs time to see our improvements in action!","type":"text"}],"type":"paragraph"},{"anchor":"Benefits-of-Type-Safe-Implementation-A-Practical-Example","type":"heading","level":3,"text":"Benefits of Type-Safe Implementation: A Practical Example"},{"inlineContent":[{"type":"text","text":"Writing software is always about making improvements. We strive to fix bugs, expand functionality, and make our code more stable and robust. Let‚Äôs consider how we can enhance our "},{"code":"TextEncoder","type":"codeVoice"},{"text":". We‚Äôve already used specific types for ","type":"text"},{"code":"TextString","type":"codeVoice"},{"type":"text","text":" in both the input and output of the encoder. Now, let‚Äôs make "},{"code":"TextEncoder","type":"codeVoice"},{"text":" more precise about what it accepts as input and what it produces as output.","type":"text"}],"type":"paragraph"},{"anchor":"Enhancing-TextEncoder-with-Distinct-Input-and-Output-Types","type":"heading","level":4,"text":"Enhancing TextEncoder with Distinct Input and Output Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let‚Äôs create different classes for storing raw text obtained from the text field and encoded text produced by the API for display on the screen:"}]},{"syntax":"java","code":["data class RawText(val body: String)","data class EncodedText(val value: String)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Both are simple wrappers around the standard ","type":"text"},{"code":"String","type":"codeVoice"},{"text":", but using such types adds a type constraint that helps prevent developers from using the API incorrectly.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Now we can update our ","type":"text"},{"code":"TextEncoder","type":"codeVoice"},{"type":"text","text":" to replace "},{"type":"codeVoice","code":"TextString"},{"type":"text","text":" with these specific types:"}]},{"syntax":"java","type":"codeListing","code":["class TextEncoder(rawText: MultiplatformFlow<RawText>) {","    @OptIn(ExperimentalEncodingApi::class)","    val encodedText: MultiplatformFlow<EncodedText> = rawText.map { text ->","        EncodedText(Base64.encode(text.body.encodeToByteArray()))","    }.multiplatform()","}"]},{"inlineContent":[{"text":"This change will result in compilation errors on both iOS and Android.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"003_01.png"},{"text":" ","type":"text"},{"type":"image","identifier":"003_02.png"},{"text":" ","type":"text"},{"type":"image","identifier":"003_03.png"}],"type":"paragraph"},{"inlineContent":[{"text":"That‚Äôs exactly what we wanted! Now both platforms behave identically. More importantly, on iOS, there is no longer a risk of breaking the app due to missed changes in the shared codebase.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Conclusion","text":"Conclusion","type":"heading"},{"inlineContent":[{"type":"text","text":"Writing cross-platform shared code in Kotlin for use in Objective-C\/Swift can be challenging, particularly when dealing with generic components in your API. Kotlin‚Äôs interoperability limitations can reduce the features supported on iOS. However, there are always workarounds and alternatives to achieve native functionality."}],"type":"paragraph"},{"inlineContent":[{"text":"In this article, we explored how to overcome some of these limitations by applying type-safe practices and adjusting implementations to work seamlessly across both platforms. By using specific types and custom wrappers, we can enhance the robustness of our cross-platform code and ensure that it behaves consistently on both iOS and Android.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"I hope this article inspires you to tackle similar challenges in your KMP projects and provides you with practical strategies for working around interoperability issues.","type":"text"}],"type":"paragraph"},{"level":3,"anchor":"For-further-reading-and-examples-check-out-the-following-resources","text":"For further reading and examples, check out the following resources:","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"reference","identifier":"https:\/\/developer.android.com\/kotlin\/interop","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"https:\/\/kotlinlang.org\/docs\/coroutines-overview.html"}]}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/combine"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A complete sample project demonstrating the concepts discussed in this article is available on "},{"type":"reference","identifier":"https:\/\/github.com\/v-volod\/KMP-Flows-Sample\/","isActive":true},{"type":"text","text":"."}]}]}],"references":{"003_01.png":{"identifier":"003_01.png","alt":"KMP","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/003_01.png"}]},"003_03.png":{"alt":"iOS","type":"image","identifier":"003_03.png","variants":[{"url":"\/images\/Me\/003_03.png","traits":["1x","light"]}]},"003_02.png":{"alt":"Android","type":"image","identifier":"003_02.png","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/003_02.png"}]},"blog-card.png":{"variants":[{"url":"\/images\/Me\/blog-card.png","traits":["1x","light"]},{"url":"\/images\/Me\/blog-card~dark.png","traits":["1x","dark"]}],"identifier":"blog-card.png","alt":null,"type":"image"},"profile-icon.png":{"identifier":"profile-icon.png","alt":null,"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/profile-icon.png"}]},"https://kotlinlang.org/docs/coroutines-overview.html":{"identifier":"https:\/\/kotlinlang.org\/docs\/coroutines-overview.html","url":"https:\/\/kotlinlang.org\/docs\/coroutines-overview.html","type":"link","title":"Kotlin Coroutines Documentation","titleInlineContent":[{"type":"text","text":"Kotlin Coroutines Documentation"}]},"doc://Me/documentation/Me/002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I":{"url":"\/documentation\/me\/002_kotlin-flow-to-swift-combine-a-kmp-bridge-part-i","title":"I. Kotlin Flow to Swift Combine: A KMP Bridge.","identifier":"doc:\/\/Me\/documentation\/Me\/002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I","type":"topic","role":"article","abstract":[{"type":"text","text":"This article explores Kotlin Flow with Swift Combine in Kotlin Multiplatform projects. It details converting between "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" and "},{"code":"Publisher","type":"codeVoice"},{"type":"text","text":", highlighting the challenges of type erasure and generics in Swift\/Objective-C interoperability, and demonstrates potential runtime issues."}],"images":[{"identifier":"kotlin_swift_bridge_logo.png","type":"icon"},{"identifier":"kotlin_swift_bridge_logo.png","type":"card"}],"kind":"article"},"002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I":{"type":"link","titleInlineContent":[{"type":"text","text":"previous part"}],"identifier":"002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I","title":"previous part","url":"002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I"},"https://github.com/v-volod/KMP-Flows-Sample/":{"type":"link","titleInlineContent":[{"type":"text","text":"GitHub"}],"identifier":"https:\/\/github.com\/v-volod\/KMP-Flows-Sample\/","title":"GitHub","url":"https:\/\/github.com\/v-volod\/KMP-Flows-Sample\/"},"doc://Me/documentation/Me/Blog":{"kind":"article","title":"Blog","abstract":[],"identifier":"doc:\/\/Me\/documentation\/Me\/Blog","url":"\/documentation\/me\/blog","images":[{"type":"icon","identifier":"blog-icon.png"},{"identifier":"blog-card.png","type":"card"}],"role":"collectionGroup","type":"topic"},"https://developer.android.com/kotlin/interop":{"type":"link","titleInlineContent":[{"type":"text","text":"Interoperability with Swift\/Objective-C"}],"identifier":"https:\/\/developer.android.com\/kotlin\/interop","title":"Interoperability with Swift\/Objective-C","url":"https:\/\/developer.android.com\/kotlin\/interop"},"doc://Me/documentation/Me":{"type":"topic","kind":"symbol","images":[{"identifier":"profile-icon.png","type":"icon"}],"url":"\/documentation\/me","title":"Me","abstract":[{"type":"text","text":"Software Engineer, primarily Mobile üì± (iOS üçé, Ex-Android ü§ñ)"}],"role":"collection","identifier":"doc:\/\/Me\/documentation\/Me"},"doc://Me/documentation/Me/001_Deep-Dive-into-SwiftUI-Containers-Key-Takeaways-from-WWDC24":{"url":"\/documentation\/me\/001_deep-dive-into-swiftui-containers-key-takeaways-from-wwdc24","title":"Deep Dive into SwiftUI Containers","type":"topic","identifier":"doc:\/\/Me\/documentation\/Me\/001_Deep-Dive-into-SwiftUI-Containers-Key-Takeaways-from-WWDC24","role":"article","abstract":[{"text":"This article delves into the new SwiftUI container APIs from WWDC24, showcasing how to build custom, flexible, and performant Layouts using advanced ","type":"text"},{"code":"ForEach","type":"codeVoice"},{"text":"\/","type":"text"},{"code":"Group","type":"codeVoice"},{"text":" initializers and ","type":"text"},{"code":"ContainerValues","type":"codeVoice"},{"text":". It covers practical implementations for section support, item limits, and expandable sections in iOS 18+ applications.","type":"text"}],"images":[{"type":"icon","identifier":"WWDC24-Icon.png"},{"type":"card","identifier":"WWDC24.jpeg"}],"kind":"article"},"kotlin_swift_bridge_logo.png":{"variants":[{"url":"\/images\/Me\/kotlin_swift_bridge_logo.png","traits":["1x","light"]}],"identifier":"kotlin_swift_bridge_logo.png","alt":null,"type":"image"},"blog-icon.png":{"identifier":"blog-icon.png","alt":null,"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/blog-icon.png"},{"traits":["1x","dark"],"url":"\/images\/Me\/blog-icon~dark.png"}]},"WWDC24.jpeg":{"variants":[{"url":"\/images\/Me\/WWDC24.jpeg","traits":["1x","light"]}],"identifier":"WWDC24.jpeg","alt":null,"type":"image"},"https://developer.apple.com/documentation/combine":{"identifier":"https:\/\/developer.apple.com\/documentation\/combine","url":"https:\/\/developer.apple.com\/documentation\/combine","type":"link","title":"Swift Combine Documentation","titleInlineContent":[{"type":"text","text":"Swift Combine Documentation"}]},"WWDC24-Icon.png":{"identifier":"WWDC24-Icon.png","alt":null,"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/Me\/WWDC24-Icon.png"}]}}}