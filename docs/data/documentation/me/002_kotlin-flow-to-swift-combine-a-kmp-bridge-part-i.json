{"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"article","seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/Me\/documentation\/Me\/003_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-II","doc:\/\/Me\/documentation\/Me\/001_Deep-Dive-into-SwiftUI-Containers-Key-Takeaways-from-WWDC24"]}],"sections":[],"topicSectionsStyle":"detailedGrid","hierarchy":{"paths":[["doc:\/\/Me\/documentation\/Me","doc:\/\/Me\/documentation\/Me\/Blog"]]},"primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"Introduction","text":"Introduction","type":"heading"},{"inlineContent":[{"type":"text","text":"Cross-platform development offers numerous opportunities to build a shared codebase, but it also introduces several limitations. If you‚Äôre working on a Kotlin Multiplatform project that handles data flows, you might have encountered challenges in bridging Kotlin‚Äôs "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" with Swift‚Äôs "},{"code":"Combine","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"In this series of articles, we will explore how to convert a KotlinFlow into a Swift Combine Publisher and vice versa. We will also examine the limitations of Kotlin to Objective-C\/Swift interoperability and discuss the issues that may arise."}],"type":"paragraph"},{"type":"heading","text":"Background","anchor":"Background","level":2},{"type":"paragraph","inlineContent":[{"text":"Kotlin Multiplatform enables us to share business logic across different platforms, making it easier to maintain consistent behavior in both iOS and Android applications. This shared code is particularly useful when identical functionality is required on both platforms. While implementing simple features is relatively straightforward, handling more complex tasks ‚Äî such as managing data streams ‚Äî can be quite challenging.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"One of the difficulties arises from the fact that there is no built-in way to convert Kotlin‚Äôs Flow into Swift‚Äôs Publisher. Developers must handle this conversion manually, which is further complicated by the different concurrency models and limitations in interoperability between Swift\/Objective-C and Kotlin. A significant challenge in this context is the restricted support for generics.","type":"text"}]},{"type":"aside","name":"Note","style":"note","content":[{"inlineContent":[{"text":"Objective-C generics do not support all features of either Kotlin or Swift, so there will be some information lost in the translation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Generics can only be defined on classes, not on interfaces (protocols in Objective-C and Swift) or functions."}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"text":"For more information on translating Kotlin code to Swift, refer to the official documentation on ","type":"text"},{"identifier":"https:\/\/kotlinlang.org\/docs\/native-objc-interop.html","isActive":true,"type":"reference"},{"text":".","type":"text"}]},{"type":"heading","text":"Using Kotlin Flows in iOS","anchor":"Using-Kotlin-Flows-in-iOS","level":2},{"type":"paragraph","inlineContent":[{"text":"Let‚Äôs explore how to define some shared sample code in Kotlin that uses ","type":"text"},{"code":"Flow","type":"codeVoice"},{"text":" for both input and output. In our example, we‚Äôve defined a ","type":"text"},{"type":"codeVoice","code":"TextEncoder"},{"text":" class that takes a ","type":"text"},{"code":"Flow","type":"codeVoice"},{"text":" of ","type":"text"},{"code":"String","type":"codeVoice"},{"text":"s as input and provides another ","type":"text"},{"code":"Flow","type":"codeVoice"},{"text":" of ","type":"text"},{"code":"String","type":"codeVoice"},{"text":"s that are Base64 encoded. This allows us to display encoded text on the fly whenever the original text changes.","type":"text"}]},{"code":["class TextEncoder(rawText: Flow<String>) {","    @OptIn(ExperimentalEncodingApi::class)","    val encodedText: Flow<String> = rawText.map { text ->","        Base64.encode(text.encodeToByteArray())","    }","}"],"syntax":"java","type":"codeListing"},{"inlineContent":[{"text":"When this Kotlin code is translated into Objective-C, it will look something like this:","type":"text"}],"type":"paragraph"},{"code":["__attribute__((objc_subclassing_restricted)) __attribute__((swift_name(\"TextEncoder\")))","@interface CommonTextEncoder : CommonBase","- (instancetype)initWithRawText:(id<CommonKotlinx_coroutines_coreFlow>)rawText __attribute__((swift_name(\"init(rawText:)\"))) __attribute__((objc_designated_initializer));","@property (readonly) id<CommonKotlinx_coroutines_coreFlow> encodedText __attribute__((swift_name(\"encodedText\")));","@end","","__attribute__((swift_name(\"Kotlinx_coroutines_coreFlow\")))","@protocol CommonKotlinx_coroutines_coreFlow","@required"],"syntax":"objc","type":"codeListing"},{"inlineContent":[{"text":"Here, ","type":"text"},{"type":"codeVoice","code":"Flow<String>"},{"text":" is translated into ","type":"text"},{"type":"codeVoice","code":"Kotlinx_coroutines_coreFlow"},{"text":". This results in a completely type-erased protocol, which loses critical information about the type we‚Äôre working with. While this issue is significant, let‚Äôs set it aside for now and focus on the core problem: mapping Combine‚Äôs ","type":"text"},{"type":"codeVoice","code":"Publisher"},{"text":" to Kotlin‚Äôs ","type":"text"},{"type":"codeVoice","code":"Flow"},{"text":".","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Map-Publisher-to-Flow","text":"Map Publisher to Flow","type":"heading"},{"inlineContent":[{"type":"text","text":"To provide text input for "},{"type":"codeVoice","code":"TextEncoder"},{"type":"text","text":", we need to implement "},{"type":"codeVoice","code":"Kotlinx_coroutines_coreFlow"},{"type":"text","text":" in Swift. First, let‚Äôs examine the "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" declaration in Kotlin:"}],"type":"paragraph"},{"code":["public interface Flow<out T> {","    public suspend fun collect(collector: FlowCollector<T>)","}"],"syntax":"java","type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"Flow"},{"type":"text","text":" is an asynchronous data stream that sequentially emits values and completes either normally or with an exception. It has one asynchronous function, "},{"type":"codeVoice","code":"collect"},{"type":"text","text":", which accepts a "},{"code":"FlowCollector","type":"codeVoice"},{"text":". The data can be collected with the provided collector until it either finishes or an exception is thrown.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"With this in mind, we can implement this protocol in Swift:","type":"text"}]},{"type":"codeListing","code":["final class Flow<P>: Kotlinx_coroutines_coreFlow where P: Publisher {","    private let values: AsyncThrowingPublisher<P>","    init(publisher: P) {","        values = publisher.values","    }","","    @MainActor","    func collect(collector: any Kotlinx_coroutines_coreFlowCollector) async throws {","        for try await value in values {","            try await collector.emit(value: value)","        }","    }","}","","extension Publisher {","    var flow: Flow<Self> {","        Flow(publisher: self)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The implementation is fairly straightforward. Combine‚Äôs ","type":"text"},{"code":"Publisher","type":"codeVoice"},{"text":" has a property ","type":"text"},{"code":"values","type":"codeVoice"},{"type":"text","text":" of type "},{"code":"AsyncThrowingPublisher","type":"codeVoice"},{"text":", which is an ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":". This allows us to asynchronously iterate over its values and call the ","type":"text"},{"code":"emit","type":"codeVoice"},{"text":" function on ","type":"text"},{"code":"Kotlinx_coroutines_coreFlowCollector","type":"codeVoice"},{"text":" (known as ","type":"text"},{"code":"FlowCollector","type":"codeVoice"},{"text":" in Kotlin) for each of them.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"That‚Äôs it. Since ","type":"text"},{"code":"collect","type":"codeVoice"},{"text":" is an asynchronous throwing function, it will execute asynchronously while there are values to process or until an error is thrown. One important detail to note is that we are executing ","type":"text"},{"code":"collect","type":"codeVoice"},{"text":" on the ","type":"text"},{"code":"MainActor","type":"codeVoice"},{"text":". This is necessary due to limitations in how Kotlin coroutines are used in Swift.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"002_main_thread_limitation.png","type":"image"}]},{"text":"Map Flow to Publisher","type":"heading","anchor":"Map-Flow-to-Publisher","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"To get our app running, we need to convert "},{"type":"codeVoice","code":"Kotlinx_coroutines_coreFlow"},{"type":"text","text":" into a "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" so that we can subscribe to it. Implementing a custom publisher requires defining the type of elements (called "},{"type":"codeVoice","code":"Output"},{"type":"text","text":"), the type of failure (which should conform to "},{"type":"codeVoice","code":"Error"},{"text":", or ","type":"text"},{"code":"Never","type":"codeVoice"},{"text":" if it doesn‚Äôt fail), and handling new subscribers. Handling new subscribers involves creating a custom ","type":"text"},{"code":"Subscription","type":"codeVoice"},{"text":" and providing it to the subscriber via the ","type":"text"},{"code":"receive(subscription:)","type":"codeVoice"},{"text":" function.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let‚Äôs take a look at the declarations of the "},{"code":"Publisher","type":"codeVoice"},{"type":"text","text":", "},{"code":"Subscription","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Subscriber","type":"codeVoice"},{"type":"text","text":" protocols:"}]},{"code":["public protocol Publisher<Output, Failure> {","    associatedtype Output","    associatedtype Failure : Error","    func receive<S>(subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input","}","","public protocol Subscription : Cancellable, CustomCombineIdentifierConvertible {","    func request(_ demand: Subscribers.Demand)","}","","public protocol Subscriber<Input, Failure> : CustomCombineIdentifierConvertible {","    associatedtype Input","    associatedtype Failure : Error","    func receive(subscription: any Subscription)","    func receive(_ input: Self.Input) -> Subscribers.Demand","    func receive(completion: Subscribers.Completion<Self.Failure>)","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Since we want to subscribe to the "},{"code":"Flow","type":"codeVoice"},{"type":"text","text":" data stream, we must provide a "},{"type":"codeVoice","code":"FlowCollector"},{"type":"text","text":" when collecting elements. We‚Äôll name the publisher class "},{"type":"codeVoice","code":"FlowCollector"},{"type":"text","text":" to keep the naming consistent. This class will store a "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" provided by the shared Kotlin library and create a "},{"type":"codeVoice","code":"FlowCollectorSubscription"},{"text":" for each new subscriber. The ","type":"text"},{"type":"codeVoice","code":"FlowCollectorSubscription"},{"text":" class will have a function called ","type":"text"},{"code":"collect","type":"codeVoice"},{"text":", which handles the actual data collection and its propagation to the subscriber.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Here‚Äôs what the ","type":"text"},{"type":"codeVoice","code":"FlowCollector"},{"type":"text","text":" publisher looks like:"}],"type":"paragraph"},{"code":["extension Publishers {","    final class FlowCollector<Output, Failure>: Publisher where Failure: Error {","        private let flow: Kotlinx_coroutines_coreFlow","","        init(flow: Kotlinx_coroutines_coreFlow) {","            self.flow = flow","        }","","        func receive<S>(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {","            let subscription = FlowCollectorSubscription(subscriber: subscriber, flow: flow)","            subscriber.receive(subscription: subscription)","            subscription.collect()","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Subscription"},{"text":" implementation is a bit more complex, so let‚Äôs break it down step by step. First, let‚Äôs declare its type conformances:","type":"text"}],"type":"paragraph"},{"code":["fileprivate final class FlowCollectorSubscription<S>: Subscription, Kotlinx_coroutines_coreFlowCollector where S: Subscriber"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"FlowCollectorSubscription"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Kotlinx_coroutines_coreFlowCollector"},{"type":"text","text":" ("},{"type":"codeVoice","code":"FlowCollector"},{"type":"text","text":" in Kotlin). Here‚Äôs its declaration:"}],"type":"paragraph"},{"code":["public fun interface FlowCollector<in T> {","    public suspend fun emit(value: T)","}"],"syntax":"java","type":"codeListing"},{"inlineContent":[{"text":"To start collecting data from the ","type":"text"},{"code":"Flow","type":"codeVoice"},{"text":", we need to call ","type":"text"},{"type":"codeVoice","code":"collect"},{"type":"text","text":" on it in an asynchronous context and provide a collector to accept elements. To do that, our "},{"type":"codeVoice","code":"Subscription"},{"type":"text","text":" should store both the "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" and the "},{"code":"Subscriber","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["fileprivate final class FlowCollectorSubscription<S>: Subscription, Kotlinx_coroutines_coreFlowCollector where S: Subscriber {","    var subscriber: S?","    let flow: Kotlinx_coroutines_coreFlow","","    init(subscriber: S?, flow: Kotlinx_coroutines_coreFlow) {","        self.subscriber = subscriber","        self.flow = flow","    }","","    func request(_ demand: Subscribers.Demand) {","        \/* Ignore demand *\/","    }","","    func collect() {","        \/\/ Handle collection","    }","","    func cancel() {","        \/\/ Handle cancellation","    }","","    func emit(value: Any?) async throws {","        \/\/ Handle new values","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Now, let‚Äôs implement the ","type":"text"},{"code":"collect","type":"codeVoice"},{"type":"text","text":" function. Since Kotlin‚Äôs "},{"type":"codeVoice","code":"Flow.collect"},{"type":"text","text":" function is asynchronous, we need to start a new unstructured task to collect data. Our "},{"code":"Subscription","type":"codeVoice"},{"text":" conforms to the ","type":"text"},{"code":"Cancellable","type":"codeVoice"},{"text":" protocol, so we need to be able to cancel our task if the subscription is canceled. We‚Äôll store a reference to our task for this purpose. In ","type":"text"},{"code":"collect","type":"codeVoice"},{"type":"text","text":", we call "},{"type":"codeVoice","code":"collect"},{"type":"text","text":" on the "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":", providing "},{"type":"codeVoice","code":"self"},{"type":"text","text":" as the collector, and wrap it in a "},{"code":"try-catch","type":"codeVoice"},{"text":" block so we can send completion to the subscriber when collection finishes either by error or successfully. Here‚Äôs what we end up with:","type":"text"}]},{"syntax":"swift","code":["fileprivate final class FlowCollectorSubscription<S>: Subscription, Kotlinx_coroutines_coreFlowCollector where S: Subscriber {","    \/\/ ...","    func collect() {","        collectionTask = .detached { @MainActor [weak self] in","            guard let self else { return }","            do {","                try await flow.collect(collector: self)","            } catch {","                if let error = error as? S.Failure {","                    subscriber?.receive(completion: .failure(error))","                } else {","                    subscriber?.receive(completion: .finished)","                }","            }","        }","    }","","    func cancel() {","        collectionTask?.cancel()","        collectionTask = nil","        subscriber = nil","    }","    \/\/ ...","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We‚Äôre halfway done. We can now subscribe to the "},{"code":"Flow","type":"codeVoice"},{"text":" and complete our publisher when it finishes. The only remaining task is to propagate the values emitted by the ","type":"text"},{"code":"Flow","type":"codeVoice"},{"text":" to the subscriber. However, since ","type":"text"},{"code":"Kotlinx_coroutines_coreFlowCollector","type":"codeVoice"},{"text":" is type-erased, we don‚Äôt know the type of the values coming from the ","type":"text"},{"type":"codeVoice","code":"Flow"},{"text":". But we do have the type of the subscriber‚Äôs ","type":"text"},{"code":"Input","type":"codeVoice"},{"text":". This is what subscribers expect to receive. We‚Äôll cast the value to this type and send it to the subscriber or throw an error if the types don‚Äôt match:","type":"text"}]},{"code":["fileprivate final class FlowCollectorSubscription<S>: Subscription, Kotlinx_coroutines_coreFlowCollector where S: Subscriber {","    struct TypeCastError: LocalizedError {","        let receivedType: Any.Type","        let expectedType: Any.Type","        var errorDescription: String? {","            \"Failed to cast value of type \\(receivedType) to expected type \\(expectedType).\"","        }","    }","","    \/\/ ..","    func emit(value: Any?) async throws {","        guard let expectedValue = value as? S.Input else {","            throw TypeCastError(receivedType: type(of: value), expectedType: S.Input.self)","        }","        _ = subscriber?.receive(expectedValue)","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Now we‚Äôre done. Let‚Äôs connect everything and test it in a sample app.","type":"text"}]},{"level":2,"anchor":"Bringing-It-All-Together","text":"Bringing It All Together","type":"heading"},{"inlineContent":[{"type":"text","text":"To demonstrate how everything is connected and works together, we will create a simple demo app that features an input field. This input field generates elements with each text change, which are then passed to the shared "},{"type":"codeVoice","code":"TextEncoder"},{"type":"text","text":" from Kotlin. The "},{"type":"codeVoice","code":"TextEncoder"},{"type":"text","text":" produces Base64 encoded strings as a "},{"type":"codeVoice","code":"Flow"},{"text":", which we will display in a label.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"I won‚Äôt delve into setting up a Kotlin Multiplatform project; instead, we‚Äôll focus on how to connect the "},{"code":"TextEncoder","type":"codeVoice"},{"type":"text","text":" in both the Android and iOS apps. Since Kotlin is native to the Android platform, let‚Äôs start there."}]},{"text":"Android implementation","type":"heading","level":3,"anchor":"Android-implementation"},{"type":"codeListing","code":["class ContentViewModel : ViewModel() {","    private val _rawText = MutableStateFlow(\"\")","    val rawText: StateFlow<String> = _rawText","","    private val _encodedText = MutableStateFlow(\"\")","    val encodedText: StateFlow<String> = _encodedText","","    private val textEncoder = TextEncoder(_rawText)","","    init {","        collectEncodedText()","    }","","    private fun collectEncodedText() {","        viewModelScope.launch {","            textEncoder.encodedText.collect { encoded ->","                _encodedText.value = encoded","            }","        }","    }","","    fun updateRawText(newText: String) {","        _rawText.value = newText","    }","}","","@Composable","fun ContentView(viewModel: ContentViewModel = viewModel()) {","    val inputText by viewModel.rawText.collectAsState()","    val encodedText by viewModel.encodedText.collectAsState()","","    Column(","        modifier = Modifier","            .padding(16.dp)","            .fillMaxSize()","    ) {","        TextField(","            value = inputText,","            onValueChange = { viewModel.updateRawText(it) },","            label = { Text(\"Enter text to encode\") },","            modifier = Modifier.fillMaxWidth()","        )","        Spacer(modifier = Modifier.height(16.dp))","        Text(","            text = \"Encoded Text: $encodedText\",","            style = MaterialTheme.typography.bodySmall","        )","    }","}"],"syntax":"swift"},{"type":"heading","text":"iOS Implementation","anchor":"iOS-Implementation","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, let‚Äôs implement a similar setup for iOS."}]},{"code":["final class ContentViewModel: ObservableObject {","    @Published var rawText: String = \"\"","    @Published var encodedText: String = \"\"","","    private var encodedTextSubscription: AnyCancellable?","","    init() {","        let textEncoder = TextEncoder(rawText: $rawText.flow)","        encodedTextSubscription = Publishers.FlowCollector(flow: textEncoder.encodedText)","            .receive(on: DispatchQueue.main)","            .assign(to: \\.encodedText, on: self)","    }","}","","struct ContentView: View {","    @StateObject private var viewModel = ContentViewModel()","","    var body: some View {","        VStack {","            TextField(\"Enter text to encode\", text: $viewModel.rawText)","                .textFieldStyle(RoundedBorderTextFieldStyle())","                .padding()","","            Text(\"Encoded Text: \\(viewModel.encodedText)\")","                .padding()","        }","        .padding()","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"With these implementations, both platforms will exhibit identical behavior."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Let‚Äôs see it in action:","type":"text"}]},{"numberOfColumns":2,"type":"row","columns":[{"size":1,"content":[{"type":"paragraph","inlineContent":[{"identifier":"002_android.gif","type":"image"}]}]},{"size":1,"content":[{"inlineContent":[{"identifier":"002_ios.gif","type":"image"}],"type":"paragraph"}]}]},{"anchor":"The-Pitfalls-of-Kotlin-Generics-in-Swift-Interoperability","type":"heading","text":"The Pitfalls of Kotlin Generics in Swift Interoperability","level":2},{"inlineContent":[{"type":"text","text":"Using the abstract "},{"type":"codeVoice","code":"Flow"},{"type":"text","text":" interface in shared KMP code can lead to type loss when translated into Swift. This results in type-unsafe code that might not be caught at compile-time but can cause runtime crashes if there are changes in the shared Kotlin library."}],"type":"paragraph"},{"text":"Demonstrating API Vulnerabilities","type":"heading","level":3,"anchor":"Demonstrating-API-Vulnerabilities"},{"inlineContent":[{"type":"text","text":"Let‚Äôs modify our "},{"type":"codeVoice","code":"TextEncoder"},{"type":"text","text":" to use a custom type for text instead of the standard "},{"code":"String","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["data class TextString(val body: String)","","class TextEncoder(rawText: Flow<TextString>) {","    @OptIn(ExperimentalEncodingApi::class)","    val encodedText: Flow<TextString> = rawText.map { text ->","        TextString(Base64.encode(text.body.encodeToByteArray()))","    }","}"],"type":"codeListing","syntax":"java"},{"inlineContent":[{"type":"text","text":"After this change, the Android project will no longer compile. This is because we‚Äôve made a breaking change in our API that requires adjustments in the codebase."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"identifier":"002_android_api_vulnerability.png","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"On iOS, however, no compilation errors will be reported. Since Kotlin‚Äôs "},{"type":"codeVoice","code":"Flow"},{"text":" is type-erased when translated to Swift, the compiler is unaware of the type changes. This will result in a runtime error.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"002_ios_api_vulnerability.png","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"What‚Äôs more concerning is that the stack trace might not clearly indicate the root cause of the issue, making it difficult to diagnose the problem."}]},{"level":3,"anchor":"Fixing-the-Type-Mismatch","type":"heading","text":"Fixing the Type Mismatch"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To resolve the type mismatch issue and ensure both the Android project compiles and the iOS project runs smoothly, we need to update the types used with "},{"code":"TextEncoder","type":"codeVoice"},{"text":". On Android, this involves simply adjusting the code to match the new API. While this is a standard practice when dealing with API changes, the situation on iOS is more challenging due to the type erasure and the lack of compile-time safety. This highlights the need for careful management of shared code across platforms.","type":"text"}]},{"level":2,"type":"heading","anchor":"Wrapping-Up","text":"Wrapping Up"},{"type":"paragraph","inlineContent":[{"text":"In this article, we explored the challenges of using Kotlin Flows in shared code for iOS and Android, focusing on the limitations and risks associated with Kotlin‚Äôs type erasure when interoperating with Swift. The type mismatch issue serves as a key example of why it‚Äôs essential to be cautious when sharing business logic across platforms.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the next article, I‚Äôll demonstrate strategies to eliminate these issues and build a more stable and type-safe Kotlin Multiplatform (KMP) codebase."}]}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Me\/documentation\/Me\/002_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-I"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/me\/002_kotlin-flow-to-swift-combine-a-kmp-bridge-part-i"]}],"abstract":[{"text":"This article explores Kotlin Flow with Swift Combine in Kotlin Multiplatform projects. It details converting between ","type":"text"},{"type":"codeVoice","code":"Flow"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Publisher"},{"text":", highlighting the challenges of type erasure and generics in Swift\/Objective-C interoperability, and demonstrates potential runtime issues.","type":"text"}],"metadata":{"role":"article","roleHeading":"Part I","title":"I. Kotlin Flow to Swift Combine: A KMP Bridge.","modules":[{"name":"Me"}],"platforms":[{"name":"","introducedAt":"2024.8.26","beta":false}],"images":[{"identifier":"kotlin_swift_bridge_logo.png","type":"icon"},{"type":"card","identifier":"kotlin_swift_bridge_logo.png"}]},"references":{"doc://Me/documentation/Me/001_Deep-Dive-into-SwiftUI-Containers-Key-Takeaways-from-WWDC24":{"type":"topic","url":"\/documentation\/me\/001_deep-dive-into-swiftui-containers-key-takeaways-from-wwdc24","identifier":"doc:\/\/Me\/documentation\/Me\/001_Deep-Dive-into-SwiftUI-Containers-Key-Takeaways-from-WWDC24","images":[{"identifier":"WWDC24-Icon.png","type":"icon"},{"identifier":"WWDC24.jpeg","type":"card"}],"abstract":[{"text":"This article delves into the new SwiftUI container APIs from WWDC24, showcasing how to build custom, flexible, and performant Layouts using advanced ","type":"text"},{"code":"ForEach","type":"codeVoice"},{"text":"\/","type":"text"},{"code":"Group","type":"codeVoice"},{"text":" initializers and ","type":"text"},{"code":"ContainerValues","type":"codeVoice"},{"text":". It covers practical implementations for section support, item limits, and expandable sections in iOS 18+ applications.","type":"text"}],"kind":"article","role":"article","title":"Deep Dive into SwiftUI Containers"},"profile-icon.png":{"type":"image","variants":[{"url":"\/images\/Me\/profile-icon.png","traits":["1x","light"]}],"identifier":"profile-icon.png","alt":null},"doc://Me/documentation/Me/003_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-II":{"type":"topic","url":"\/documentation\/me\/003_kotlin-flow-to-swift-combine-a-kmp-bridge-part-ii","identifier":"doc:\/\/Me\/documentation\/Me\/003_Kotlin-Flow-to-Swift-Combine-A-KMP-Bridge-Part-II","images":[{"identifier":"kotlin_swift_bridge_logo.png","type":"icon"},{"type":"card","identifier":"kotlin_swift_bridge_logo.png"}],"abstract":[{"type":"text","text":"This article resolves KMP type-safety issues when bridging Kotlin Flows to Swift Combine. It uses "},{"type":"codeVoice","code":"MultiplatformFlow"},{"type":"text","text":", a generic wrapper, to ensure type safety in both directions, enabling consistent compile-time error detection across Android and iOS."}],"kind":"article","role":"article","title":"II. Kotlin Flow to Swift Combine: A KMP Bridge."},"002_android_api_vulnerability.png":{"type":"image","alt":"Android compile error screenshot","variants":[{"url":"\/images\/Me\/002_android_api_vulnerability.png","traits":["1x","light"]}],"identifier":"002_android_api_vulnerability.png"},"kotlin_swift_bridge_logo.png":{"type":"image","alt":null,"variants":[{"url":"\/images\/Me\/kotlin_swift_bridge_logo.png","traits":["1x","light"]}],"identifier":"kotlin_swift_bridge_logo.png"},"https://kotlinlang.org/docs/native-objc-interop.html":{"identifier":"https:\/\/kotlinlang.org\/docs\/native-objc-interop.html","type":"link","url":"https:\/\/kotlinlang.org\/docs\/native-objc-interop.html","title":"Interoperability with Swift\/Objective-C","titleInlineContent":[{"type":"text","text":"Interoperability with Swift\/Objective-C"}]},"002_android.gif":{"type":"image","alt":"Android","variants":[{"url":"\/images\/Me\/002_android.gif","traits":["1x","light"]}],"identifier":"002_android.gif"},"002_ios.gif":{"type":"image","alt":"Android","variants":[{"url":"\/images\/Me\/002_ios.gif","traits":["1x","light"]}],"identifier":"002_ios.gif"},"doc://Me/documentation/Me/Blog":{"title":"Blog","kind":"article","url":"\/documentation\/me\/blog","type":"topic","identifier":"doc:\/\/Me\/documentation\/Me\/Blog","abstract":[],"role":"collectionGroup","images":[{"type":"icon","identifier":"blog-icon.png"},{"type":"card","identifier":"blog-card.png"}]},"WWDC24.jpeg":{"type":"image","alt":null,"variants":[{"url":"\/images\/Me\/WWDC24.jpeg","traits":["1x","light"]}],"identifier":"WWDC24.jpeg"},"002_main_thread_limitation.png":{"type":"image","alt":"Main thread limitation","variants":[{"url":"\/images\/Me\/002_main_thread_limitation.png","traits":["1x","light"]}],"identifier":"002_main_thread_limitation.png"},"002_ios_api_vulnerability.png":{"variants":[{"url":"\/images\/Me\/002_ios_api_vulnerability.png","traits":["1x","light"]}],"identifier":"002_ios_api_vulnerability.png","alt":"iOS runtime error screenshot","type":"image"},"WWDC24-Icon.png":{"alt":null,"variants":[{"url":"\/images\/Me\/WWDC24-Icon.png","traits":["1x","light"]}],"type":"image","identifier":"WWDC24-Icon.png"},"blog-icon.png":{"type":"image","variants":[{"url":"\/images\/Me\/blog-icon.png","traits":["1x","light"]},{"url":"\/images\/Me\/blog-icon~dark.png","traits":["1x","dark"]}],"identifier":"blog-icon.png","alt":null},"doc://Me/documentation/Me":{"identifier":"doc:\/\/Me\/documentation\/Me","images":[{"identifier":"profile-icon.png","type":"icon"}],"role":"collection","kind":"symbol","url":"\/documentation\/me","type":"topic","abstract":[{"type":"text","text":"Software Engineer, primarily Mobile üì± (iOS üçé, Ex-Android ü§ñ)"}],"title":"Me"},"blog-card.png":{"type":"image","variants":[{"url":"\/images\/Me\/blog-card.png","traits":["1x","light"]},{"url":"\/images\/Me\/blog-card~dark.png","traits":["1x","dark"]}],"identifier":"blog-card.png","alt":null}}}